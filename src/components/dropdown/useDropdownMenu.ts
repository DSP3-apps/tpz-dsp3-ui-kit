import { useState, useRef, useId, useEffect, useMemo, HTMLAttributes } from 'react';

import { ExtendProps } from '@/utils/types';

/**
 * The current state of the menu
 */
export type DropdownMenuState = { state: { isOpen: boolean } };

// use a data attribute with a unique value to tell us which elements belong to the current menu
type DropdownMenuAttribute = { 'data-menu': string };

/**
 * The props that are passed into the button that is used to open/close the menu.
 */
export type ButtonRendererProps = ExtendProps<'button', DropdownMenuState>;

// can't use `ExtendProps` here since we just want the most base level of HTML attributes.
// a number of elements use only these props, like `abbr`, but that implies the menu
// item is an `<abbr>` which isn't strictly true, and so qualifying it ourselves is better
/**
 * The props passed into each child item of the menu.
 */
export type ItemRendererProps = HTMLAttributes<HTMLElement>;

export type DropdownMenuHook = {
  isOpen: boolean;
  buttonProps: ButtonRendererProps & DropdownMenuAttribute;
  itemProps: (ItemRendererProps & DropdownMenuAttribute)[];
  selectedItemIndex: number;
};

/**
 * This hook handles the behaviour and accessibility concerns when creating a dropdown menu (*not* a select menu).
 * while leaving all the styling and design up to the user.
 *
 * The hook returns an object with 4 keys:
 * - `isOpen`: Whether the dropdown is open or not.
 * - `buttonProps`: These props are generated by the hook and need to be passed down (via spreading) into the `button` element
 * that the user can click to open/close the menu. Other attributes can be applied to the button along side these, but at minimum
 * these MUST be added.
 * - `itemProps`: These props are also generated by the hook, but they should be passed down to each item displayed in the menu.
 * Since the style and design is up to the user, when you create the menu children from some data, you can use the index to get
 * the props for each item and spread them in. For example:
 *   ```tsx
 *     data.map((_, i) => <div {...itemProps[i]}></div>)
 *   ```
 * - `selectedItemIndex`: This represents which item was last selected by the user.
 *
 * ### NOTES:
 * This hook makes use of `refs`. For that reason, the menu items **must not** be unmounted from the DOM via a conditional statement with `isOpen`.
 * Instead, you can show/hide the menu item container using its `display` or `visibility`  style and set it to a different value depending on
 * if the menu is open or not. This does not affect accessibility.
 *
 * Keyboard interactivity sources:
 * https://www.w3.org/WAI/ARIA/apg/patterns/menubar/examples/menubar-navigation/
 *
 * @param itemCount The number of items to show in the menu.
 * @returns
 */
export const useDropdownMenu = (itemCount: number): DropdownMenuHook => {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(0);

  const currentFocusIndex = useRef<number | null>(null);

  const menuId = useId();

  // track the refs of each child so they can be focussed for accessibility
  // this is memoified so it only updates when the number of items changes
  const itemRefs: { current: Record<number, HTMLElement | null> } = useMemo(
    () => ({ current: {} }),
    [itemCount],
  );

  // use the unique id to determive if a given element is part of the menu
  const isMenuItem = (element: Element | null): boolean => {
    return (
      element?.getAttribute('data-menu') === menuId ||
      // get the closest element with that id, essentially checking if we are a child somewhere down the line
      element?.closest(`[data-menu="${menuId}"]`) !== null
    );
  };

  const focusItem = (index: number) => {
    currentFocusIndex.current = index;
    itemRefs.current[index]?.focus();
  };

  const selectItem = (index: number) => {
    setSelectedItem(index);
    setIsOpen(false);
  };

  useEffect(() => {
    if (isOpen) {
      focusItem(0);
    }
  }, [isOpen]);

  useEffect(() => {
    // handles exiting the menu when the `Escape` key is pressed
    const escapeExitMenuHandler = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && document.activeElement && isMenuItem(document.activeElement)) {
        event.preventDefault();

        setIsOpen(false);
      }
    };

    // handles exiting the menu when focus moved to another element
    const blurExitMenuHandler = () => {
      if (!isMenuItem(document.activeElement)) {
        setIsOpen(false);
      }
    };

    // handles exiting the menu when the user clicks/touches outside the menu
    const clickExitMenuHandler = (event: PointerEvent) => {
      if (event.button === 0 && !isMenuItem(event.target as Element)) {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', escapeExitMenuHandler);
    // `passive` events just mean we dont call `preventDefault` and it allows the browser to be a bit smarter about the events
    // `capture` is a bit more complicated but from what I understand it essentially makes it so this event handler fires BEFORE
    // the element gets the event, whereas without it it would trigger AFTER the element recieved the event
    document.addEventListener('focus', blurExitMenuHandler, { capture: true, passive: true });
    //  make use of pointer events instead of click events to support touch devices.
    document.addEventListener('pointerup', clickExitMenuHandler, { passive: true });

    return () => {
      window.removeEventListener('keydown', escapeExitMenuHandler);
      document.removeEventListener('focus', blurExitMenuHandler);
      document.removeEventListener('pointerup', clickExitMenuHandler);
    };
  }, []);

  return {
    isOpen,
    selectedItemIndex: selectedItem,

    buttonProps: {
      state: { isOpen },
      'data-menu': menuId,
      'aria-haspopup': 'menu',
      'aria-expanded': isOpen,

      onPointerUp: () => setIsOpen(!isOpen),
      onKeyDown: (event) => {
        //  space and enter act more like clicking and can toggle the menu open/closed
        if (event.key === ' ' || event.key === 'Enter') {
          event.preventDefault();

          setIsOpen(!isOpen);
        }

        // the down arrow should open the menu
        if (event.key === 'ArrowDown') {
          event.preventDefault();

          if (!isOpen) {
            setIsOpen(true);
          } else {
            focusItem(0);
          }
        }
      },
    },

    itemProps: Array.from({ length: itemCount }, (_, itemIndex) => ({
      key: itemIndex,

      role: 'menuitem',
      // the items in the menu should not be focussable. using `Tab` should move the focus away from the menu entirely.
      // only arrow keys should navigate each item
      tabIndex: -1,
      'data-menu': menuId,

      ref: (el: HTMLElement) => {
        itemRefs.current[itemIndex] = el;
      },

      // by using a 0 second `setTimeout` the event handler is moved to the bottom of the stack
      // this is important because it means our handler is fired AFTER the default behaviour
      // without the setTimeout things like links might not work properly because the menu
      // would hide BEFORE the browsers own default click handler could redirect you
      onPointerUp: () => setTimeout(() => selectItem(itemIndex), 0),
      onKeyDown: (event) => {
        let focusIndex = currentFocusIndex.current;

        // close the menu if you "select" an item
        if (event.key === ' ' || event.key === 'Enter') {
          event.preventDefault();

          // we just called `preventDefault` so we need to manually click it otherwise nothing will happen
          // the reason we must call `preventDefault` is to avoid other behaviour like spacebar scrolling the page
          itemRefs.current[itemIndex]?.click();

          selectItem(itemIndex);
        }

        if (focusIndex !== null) {
          // arrow keys should cycle through each item in the menu
          if (event.key === 'ArrowDown') {
            event.preventDefault();

            focusIndex += 1;
          } else if (event.key === 'ArrowUp') {
            event.preventDefault();

            focusIndex -= 1;
          }

          // allow wrapping of focus
          if (focusIndex > itemCount - 1) {
            focusIndex = 0;
          } else if (focusIndex < 0) {
            focusIndex = itemCount - 1;
          }

          focusItem(focusIndex);
        }
      },
    })),
  };
};
